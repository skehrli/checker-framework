\htmlhr
\chapterAndLabel{Resource Leak Checker for must-call obligations}{resource-leak-checker}

The Resource Leak Checker guarantees that the program fulfills every object's
must-call obligations before the object is de-allocated.

A resource leak occurs when a program does not explicitly dispose of some finite
underlying resource, such as a socket, file descriptor, or database connection.  To dispose
of the resource, the program should call some method on an object.
(De-allocating or garbage-collecting the object is not sufficient.)  For
example, the program must call \<close()> on every object that implements the
interface \<java.io.Closeable>.

The Resource Leak Checker can check any property of the form ``the programmer
must call each method in a set of methods \emph{M} at least once
on object \emph{O} before \emph{O} is de-allocated''.  For resource leaks,
by default \emph{M} is the set containing
\<close()> and \emph{O} is any object that implements the interface
\<java.io.Closeable>.  You can extend this guarantee to other types and methods
by writing \<@MustCall> or \<@InheritableMustCall> annotations, as described in
Section~\ref{must-call-annotations}.

The Resource Leak Checker works in three stages:
\begin{enumerate}
\item The Must Call Checker (\chapterpageref{must-call-checker})
  over-approximates each expression's must-call methods as a
  \refqualclass{checker/mustcall/qual}{MustCall} type.
\item The Called Methods Checker (\chapterpageref{called-methods-checker})
  under-approximates each expression's definitely-called methods as a
  \refqualclass{checker/calledmethods/qual}{CalledMethods} type.
\item When any program element goes out of scope (i.e., it is ready to be
  de-allocated), the Resource Leak Checker compares the types
  \<@MustCall(\emph{MC})> and \<@CalledMethods(\emph{CM})>.  It reports an error
  if there exists some method in \emph{MC} that is not in \emph{CM}.
\end{enumerate}

The paper
``Lightweight and Modular Resource Leak Verification''~\cite{KelloggSSE2021} (ESEC/FSE 2021,
\myurl{https://homes.cs.washington.edu/~mernst/pubs/resource-leak-esecfse2021-abstract.html})
gives more details about the Resource Leak Checker.


\sectionAndLabel{How to run the Resource Leak Checker}{resource-leak-run-checker}

Run one of these lines:

\begin{Verbatim}
javac -processor resourceleak MyFile.java ...
javac -processor org.checkerframework.checker.resourceleak.ResourceLeakChecker MyFile.java ...
\end{Verbatim}

The Resource Leak Checker supports all the command-line arguments
listed in Section~\ref{called-methods-run-checker} for
the Called Methods Checker, plus three others:

\begin{description}
\item[\<-ApermitStaticOwning>]
  See Section~\ref{resource-leak-owning-fields}.
\item[\<-AresourceLeakIgnoredExceptions=...>]
  See Section~\ref{resource-leak-ignored-exceptions}.
\item[\<-ApermitInitializationLeak>]
  See Section~\ref{resource-leak-field-initialization}.
%% TODO: Uncomment when the feature is ready to be publicized.
% \item[\<-AenableWpiForRlc>]
%   See Section~\ref{resource-leak-checker-inference-algo}.
\end{description}

If you are running the Resource Leak Checker, then there is no need to run
the Must Call Checker (\chapterpageref{must-call-checker}), because the
Resource Leak Checker does so automatically.


\sectionAndLabel{Resource Leak Checker annotations}{resource-leak-annotations}

The Resource Leak Checker relies on the type qualifiers of two other checkers:
the Must Call Checker (Section~\ref{must-call-annotations}) and
the Called Methods Checker (Section~\ref{called-methods-spec}). You might need
to write qualifiers from either type hierarchy. The most common annotations from
these checkers that you might need to write are:

\begin{description}

\item[\refqualclasswithparams{checker/mustcall/qual}{MustCall}{String[] value}]
for example on an element with compile-time type \<Object> that might contain a \<Socket>.
See Section~\ref{must-call-annotations}.

\item[\refqualclasswithparams{checker/mustcallonelements/qual}{MustCallOnElements}{String[] value}]
expresses the must-call obligations of the elements of an array or
collection. This is rarely written; the most common use case is to specify the
obligations of an \<@OwningCollection> method parameter. See
Section~\ref{resource-leak-collections-mcoe-cmoe}.

\item[\refqualclasswithparams{checker/mustcall/qual}{InheritableMustCall}{String[] value}]
on any classes defined in your program that have must-call obligations. See Section~\ref{must-call-on-class}.

\item[\refqualclass{checker/calledmethods/qual}{EnsuresCalledMethods} and/or
      \refqualclass{checker/calledmethods/qual}{EnsuresCalledMethodsOnException}]
on a method in your code that fulfills a must-call obligation of one of its parameters or of a field.
See Section~\ref{called-methods-ensurescalledmethods}.

\item[\refqualclass{checker/calledmethodsonelements/qual}{EnsuresCalledMethodsOnElements} and/or
      \refqualclass{checker/calledmethodsonelements/qual}{EnsuresCalledMethodsOnElementsOnException}]
on a method in your code that fulfills a \MustCallOnElements obligation of
one of its collection parameters or of an \<@OwningCollection> field. See
Section~\ref{resource-leak-collections-mcoe-cmoe}.

\end{description}

The Resource Leak Checker supports annotations that express
aliasing patterns related to resource leaks:

\begin{description}

\item[\refqualclass{checker/mustcall/qual}{Owning}]
\item[\refqualclass{checker/mustcall/qual}{NotOwning}]
  expresses ownership.  When two aliases exist to the same Java object,
  \<@Owning> and \<@NotOwning> indicate which of the two is responsible for
  fulfilling must-call obligations.
  Constructor results are always \<@Owning>. Method returns default to
  \<@Owning>.  Formal parameters and fields default to \<@NotOwning>.
  For more details, see Section~\ref{resource-leak-ownership}.
\item[\refqualclass{checker/mustcallonelements/qual}{OwningCollection}]
  Every array or collection that is not explicitly annotated as \<@OwningCollection> is not owning. It is a compile-time error if an expression with a must-call obligation is assigned into an element of an array or collection that does not have an \<@OwningCollection> annotation. For more details, see Section~\ref{resource-leak-collections}.

\item[\refqualclass{checker/mustcall/qual}{MustCallAlias}]
  represents a ``resource-aliasing'' relationship.  Two resource aliases are
  two distinct Java objects that control the same resource(s):
  fulfilling the must-call obligations of one object also
  fulfills the obligations of the other object.  For details,
  see Section~\ref{resource-leak-resource-alias}.

\end{description}

The Resource Leak Checker also supports an annotation to permit re-assigning
fields or re-opening resources:

\begin{description}

\item[\refqualclasswithparams{checker/mustcall/qual}{CreatesMustCallFor}{String value}]
  is a declaration annotation that indicates that after a call to a method
  with this annotation none of the must-call obligations of the in-scope, owning expression
  listed in \<value> have been met.
  In other words, the annotated method ``resets'' the must-call obligations of the expression.
  Multiple \<@CreatesMustCallFor>
  annotations can be written on the same method.  Section~\ref{resource-leak-createsmustcallfor}
  explains how this annotation permits re-assignment of owning
  fields or the re-opening of resources.

\end{description}


\sectionAndLabel{Example of how safe resource usage is verified}{resource-leak-example}

Consider the following example of safe use of a \<Socket>, in which the comments indicate the
inferred Must Call and Called Methods type qualifiers for \<s>:
\begin{verbatim}
{
  Socket s = null;
  // 1. @MustCall({}) @CalledMethodsBottom
  try {
    s = new Socket(myHost, myPort);
    // 2. @MustCall("close") @CalledMethods({})
  } catch (Exception e) {
    // do nothing
  } finally {
    if (s != null) {
      s.close();
      // 3. @MustCall("close") @CalledMethods("close")
    } else {
      // do nothing
      // 4. @MustCall("close") @CalledMethodsBottom
    }
    // 5. @MustCall("close") @CalledMethods("close")
  }
  // 6. @MustCall("close") @CalledMethods("close")
}
\end{verbatim}

At point 1, \<s>'s type qualifiers are the type qualifiers of \<null>:
\<null> has no must-call obligations (\<@MustCall(\{\})>),
and methods cannot be called on it (\<@CalledMethodsBottom>).

At point 2, \<s> is a new \<Socket> object, which
has a must-call obligation (\<@MustCall("close")>)
and has had no methods called on it (\<@CalledMethods(\{\})>).

At point 3, \<close()> has definitely been called on \<s>, so
\<s>'s Called Methods type is updated. Note that the Must Call type
does not change.

At point 4, \<s> is definitely \<null> and its type is adjusted accordingly.

At point 5, \<s>'s type is the least upper bound of the types at points 3
and 4.

At point 6, \<s> goes out of scope.  The Resource Leak Checker reports a
\<required.method.not.called> error if the Must Call set contains any
element that the Called Methods set does not.

\sectionAndLabel{Aliased references and ownership transfer}{resource-leak-ownership}

Resource leak checking is complicated by aliasing.  Multiple expressions
may evaluate to the same Java object, but each object only needs to be
closed once.  (Section~\ref{resource-leak-resource-alias} describes a
related situation called ``resource aliasing'', when multiple distinct Java objects
refer to the same underlying resource.)

For example, consider the following code that safely closes a \<Socket>:

\begin{verbatim}
  void example(String myHost, int myPort) throws IOException {
    Socket s = new Socket(myHost, myPort);
    closeSocket(s);
  }
  void closeSocket(@Owning @MustCall("close") Socket t) {
    try {
      t.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
\end{verbatim}

There are two aliases for a socket object: \<s> in \<example()> and \<t> in
\<closeSocket()>.  Ordinarily, the Resource Leak Checker requires that
\<close()> is called on every expression of type \<Socket>, but that is not
necessary here.  The Resource Leak Checker should not warn when
\<s> goes out of scope in \<example()>, because \<closeSocket()> takes ownership
of the socket --- that is, \<closeSocket()> takes responsibility for closing
it. The \<@Owning> annotation on \<t>'s declaration expresses this fact; it
tells the Resource Leak Checker that \<t> is the reference that must be
closed, and its alias \<s> need not be closed.

Constructor returns are always \<@Owning>.
Method returns default to \<@Owning>,
and parameters and fields default to \<@NotOwning>. This treatment of parameter and
return types ensures sound handling of unannotated third-party libraries: any
object returned from such a library will be tracked by default, and the checker
never assumes that passing an object to an unannotated library will satisfy its obligations.

\<@Owning> and \<@NotOwning> always \emph{transfer} must-call obligations: must-call
obligations are conserved (i.e., neither created nor destroyed) by ownership annotations.
Writing \<@Owning> or \<@NotOwning> can never make the checker
unsound:  a real warning can never be hidden by them.
As with any annotation, incorrect or missing annotations can lead to false positive warnings.

\subsectionAndLabel{Owning parameters and exceptions}{resource-leak-owning-parameters-and-exceptions}

When \<@Owning> is written on a method parameter, the method only takes ownership of the
parameter when it returns normally.  In this example, the Resource Leak Checker will report
an error in the \<example> method and allow the definition of \<closeSocket>:

\begin{verbatim}
  void example(String myHost, int myPort) throws Exception {
    // Error: `s` is not closed on all paths
    Socket s = new Socket(myHost, myPort);

    // `closeSocket` does not have to close `s` when it throws IOException.
    // Instead, this method has to catch the exception and close `s`.
    closeSocket(s);
  }

  void closeSocket(@Owning Socket t) throws IOException {
    ...
  }
\end{verbatim}

Sometimes a method really does promise to call some methods on an \<@Owning> parameter,
if the method throws an exception.  The annotation \<@EnsuresCalledMethodsOnException> can
express this situation.  For example, a constructor that throws an exception might
choose to close an \<@Owning> parameter instead of letting ownership remain with the caller:

\begin{verbatim}
  @EnsuresCalledMethodsOnException(value = "#1", methods = "close")
  public Constructor(@Owning Closeable resource) {
    this.resource = resource;
    try {
      initialize();
    } catch (Exception e) {
      resource.close();
      throw e;
    }
  }
\end{verbatim}

\subsectionAndLabel{Owning fields}{resource-leak-owning-fields}

Unannotated fields are treated as non-owning.

For \textbf{final, non-static owning fields},
the Resource Leak Checker enforces the ``resource acquisition is
initialization (RAII)'' programming idiom.  Some
destructor-like method \<d()> must satisfy the field's must-call obligation
(and this fact must be expressed via a \<@EnsuresCalledMethods> annotation on \<d()>),
and the enclosing class must have a \<@MustCall("d")> obligation to
ensure the destructor is called. In addition to the \<@EnsuresCalledMethods> annotation,
which guarantees that the field(s) it references have their must-call obligations satisfied
on non-exceptional paths, the Resource Leak Checker requires those fields to have their must-call
obligations satisfied on all paths in (only) the destructor, and will issue a \<destructor.exceptional.postcondition>
error if they are not satisfied. Resolve this error by ensuring that the required methods are called
on all exceptional paths.

\textbf{Non-final, non-static owning fields} usually require one or more \<@CreatesMustCallFor> annotations
when they might be re-assigned. See Section~\ref{resource-leak-createsmustcallfor} for
more details on how to annotate a non-final, non-static owning field.

Owning fields are treated slightly differently in constructors than in normal methods.
In normal methods, assigning a value to an owning field always satisfies the object's
must-call obligations.  However, within a constructor, those obligations are only
satisfied if the constructor returns normally.  If the constructor throws an exception,
the constructed object will not be accessible afterward, and therefore its fields need
to be closed before it exits.

This constructor safely closes the object it allocates before throwing an exception:
\begin{verbatim}
  private final @Owning Socket socket;

  public ConstructorThatCanThrow() throws IOException {
    Socket s = new Socket(myHost, myPort);
    try {
      initialize(s); // may throw IOException
    } catch (Exception e) {
      s.close();
      throw e;
    }
    this.socket = s;
  }
\end{verbatim}

An assignment to a \textbf{static owning field} does not satisfy a
must-call obligation; for example,

\begin{smaller}
\begin{Verbatim}
  static @Owning PrintWriter debugLog = new PrintWriter("debug.log");
\end{Verbatim}
\end{smaller}

\noindent
The Resource Leak Checker issues a warning about every assignment of an
object with a must-call annotation into a static owning field,
indicating that the obligation of the field's content might not be
satisfied.  When those fields are used throughout execution, until the
program exits, there is no good place to dispose of them, so these warnings
might not be useful.  The \<-ApermitStaticOwning> command-line argument
suppresses warnings related to static owning fields.  This can help in
checking legacy code.  It permits only a small number of resource retained
throughout execution, related to the number of such fields and assignments
to them.


\sectionAndLabel{Resource aliasing}{resource-leak-resource-alias}

A \emph{resource alias} set is a set of Java objects that
correspond to the same underlying system resource.
Calling a must-call method on any member of a resource-alias set
fulfills that obligation for all members of the set.
Members of the set may have different Java types.

Programmers most often encounter resource aliasing when using \emph{wrapper types}.
For example, the Java \<Buffered\-Output\-Stream> wrapper adds buffering to a
delegate stream.
The wrapper's \<close()> method invokes \<close()> on the delegate.  Calling
\<close()> on either object has the same effect:  it closes the underlying resource.

A resource aliasing relationship is expressed in source code via a pair of \<@MustCallAlias> annotations:
one on a parameter of a method or constructor, and another on its return type.
For example, the annotated JDK contains this constructor of \<BufferedOutputStream>:
\begin{Verbatim}
@MustCallAlias BufferedOutputStream(@MustCallAlias OutputStream out);
\end{Verbatim}

When a pair of \<@MustCallAlias> annotations is written on a method or constructor \<m>'s return type
and its parameter \<p>, the Resource Leak Checker requires one of the following:
\begin{enumerate}
\item \<p> is passed to another method or constructor (including \<super>) in a
  \<@MustCallAlias> position, and \<m> returns that method's result, or
\item \<p> is stored in the only \<@Owning> field of the enclosing class (a class with more than one
  \<@Owning> field cannot have a resource alias relationship).
\end{enumerate}

\subsectionAndLabel{A complete wrapper type example}{resource-leak-wrapper-type-example}

Here is a complete example of a type \<InputStreamWrapper> that wraps an \<InputStream> as a resource alias.  Defining a wrapper type typically involves combined usage of \<@InheritableMustCall>, \<@EnsuresCalledMethods>, an \<@Owning> field, and \<@MustCallAlias>.  The \<test> method shows that the checker is able to verify code that releases an \<InputStream> using either the \<InputStream> directly or a wrapping \<InputStreamWrapper>.

\begin{verbatim}
@InheritableMustCall("dispose")
class InputStreamWrapper {
  private final @Owning InputStream stream;

  @MustCallAlias InputStreamWrapper(@MustCallAlias InputStream stream) {
    this.stream = stream;
  }

  @EnsuresCalledMethods(value = "this.stream", methods = "close")
  public void dispose() throws IOException {
    this.stream.close();
  }

  /** Shows that either the stream or the wrapper can be closed. */
  static void test(@Owning InputStream stream, boolean b) throws IOException {
    InputStreamWrapper wrapper = new InputStreamWrapper(stream);
    if (b) {
      stream.close();
    } else {
      wrapper.dispose();
    }
  }
}
\end{verbatim}


\sectionAndLabel{Creating obligations (how to re-assign a non-final owning field)}{resource-leak-createsmustcallfor}

Consider a class that has must-call obligations; that is, the class
declaration is annotated with \<@MustCall(...)>.
Every constructor implicitly creates obligations for the newly-created object.
Non-constructor methods may also create obligations
when re-assigning non-final owning fields or allocating
new system-level resources.

A post-condition annotation,
\<@CreatesMustCallFor>,
indicates for which expression an obligation is created.
If you write \<@CreatesMustCallFor(>\emph{T}\<)> on a method \emph{N} that
overrides a method \emph{M}, then \emph{M} must also be annotated as
\<@CreatesMustCallFor(>\emph{T}\<)>.  (\emph{M} may also have other
\<@CreatesMustCallFor> annotations that \emph{N} does not.)

\<@CreatesMustCallFor> allows the Resource Leak Checker to verify uses of non-final fields
that contain a resource, even if they are re-assigned. Consider
the following example:

\begin{verbatim}
  @MustCall("close") // default qualifier for uses of SocketContainer
  class SocketContainer {
    private @Owning Socket sock;

    public SocketContainer() { sock = ...; }

    void close() { sock.close() };

    @CreatesMustCallFor("this")
    void reconnect() {
      if (!sock.isClosed()) {
        sock.close();
      }
      sock = ...;
    }
  }
\end{verbatim}

In the lifetime of a \<SocketContainer> object, \<sock>
might be re-assigned arbitrarily many times: once at each
call to \<reconnect()>. This code is safe, however: \<reconnect()>
ensures that \<sock> is closed before re-assigning it.

Sections~\ref{resource-leak-createsmustcallfor-callsite}
and~\ref{resource-leak-createsmustcallfor-declaration}
explain how the Resource Leak Checker verifies uses and declarations of
methods annotated with \<@CreatesMustCallFor>.


\subsectionAndLabel{Requirements at a call site of a \<@CreatesMustCallFor> method}{resource-leak-createsmustcallfor-callsite}

At a call site to a method annotated as
\<@CreatesMustCallFor(>\emph{expr}\<)>, the Resource Leak Checker:
\begin{enumerate}
\item
  Treats any existing \<@MustCall> obligations of \emph{expr} as \emph{satisfied},
\item
  Creates a fresh obligation to check, as if \emph{expr} was assigned to a newly-allocated
  object (i.e. as if \emph{expr} were a constructor result).
\item
  Un-refines the type in the Called Methods Checker's type hierarchy for \emph{expr} to
  \<@CalledMethods(\{\})>, if it had any other Called Methods type.
\item
  Requires that the expression corresponding to \emph{expr} (that is, \emph{expr}
  viewpoint-adapted to the method call site) is owned; that is, it is
  annotated or defaulted as \<@Owning>.  Otherwise, the checker
  will issue a \<reset.not.owning> error at the call site. You can avoid this
  error by extracting \emph{expr} into a new local variable (because
  locals are \<@Owning> by default) and replacing all instances of \emph{expr}
  in the call with references to the new local variable.
\end{enumerate}

Treating the obligation before the call as satisfied is sound: the
checker creates a new obligation for calls to \<@CreatesMustCallFor> methods,
and the Must Call Checker (\chapterpageref{must-call-checker}) ensures the
\<@MustCall> type for the target expression will have a \emph{superset} of any methods
present before the call. Intuitively, calling an \<@CreatesMustCallFor> method
``resets'' the obligations of the target expression, so whether they were satisfied before
the call or not is irrelevant.

If an \<@CreatesMustCallFor>
method \emph{n} is invoked within a method \emph{m} that has an \<@CreatesMustCallFor> annotation,
and the \<@CreatesMustCallFor> annotations on \emph{n} and \emph{m} have
the same target expression---imposing the obligation produced by calling \emph{n} on the caller of \emph{m}---then
the newly-created obligation is treated as satisfied immediately
at the call site of \emph{n} in the body of \emph{m} (because it is imposed at call sites of \emph{m}
instead).


\subsectionAndLabel{Requirements at a declaration of a \<@CreatesMustCallFor> method}{resource-leak-createsmustcallfor-declaration}

Any method that re-assigns a non-final, owning field of some object \<obj>
must be annotated \<@CreatesMustCallFor("obj")>.
Other methods may also be annotated with \<@CreatesMustCallFor>.

The Resource Leak Checker enforces two rules to ensure that re-assignments
to non-final, owning fields (like \<sock> in method \<reconnect> above) are
sound:
\begin{itemize}
\item any method that re-assigns a non-final, owning field of an object
  must be annotated with a \<@CreatesMustCallFor> annotation
  whose expression is a reference to that object.
\item when a non-final, owning field $f$ is re-assigned at statement $s$,
  at the program point before $s$, $f$'s must-call obligations must have been satisfied.
\end{itemize}
\noindent
The first rule ensures that \<close()> is called after the last call
to \<reconnect()>, and the second rule ensures that \<reconnect()>
safely closes \<sock> before re-assigning it. Because the Called Methods Checker
treats calls to an \<@CreatesMustCallFor> method like \<reconnect()> as if the call might
cause arbitrary side-effects, after such a call the only method known to have been
definitely called is the \<@CreatesMustCallFor> method: previous called
methods (including \<close()>) do not appear in the \<@CalledMethods> type qualifier.

% TODO: should this section also include text about unconnected sockets, or is what's here sufficient?


\sectionAndLabel{Ignored exception types}{resource-leak-ignored-exceptions}

The Resource Leak Checker checks that an element's must-call obligations
are fulfilled when that element may go out of scope: at the end of its
lexical scope or when control may be transferred to the end of its lexical
scope, such as via a \<break> or \<continue> statement or via throwing an
exception.  As an example of an exception, consider the following method:

\begin{verbatim}
  void foo() {
    Socket s = ...;
    bar();
    s.close();
  }
\end{verbatim}

If \<bar> is declared to throw an exception, the Resource Leak Checker
warns that a \<Socket> may be leaked.  If \<bar> throws an exception, the
only reference to \<s> is lost, which could lead to a resource leak.

The Resource Leak Checker ignores control flow due to some exceptions.

\begin{itemize}
\item
By default the Resource Leak Checker ignores run-time errors that can occur
unpredictably at most points in the program. For example, the JVM can throw
an \<OutOfMemoryError> on any allocation.  Similarly,
\<ClassCircularityError>, \<ClassFormatError>, and \<NoClassDefFoundError>
may occur at any reference to a class.  Such exceptions usually terminate
the program, and in that case unclosed resources do not matter.
Furthermore, any method can throw \<RuntimeException>, and the Checker
Framework pessimistically assumes one can be thrown at every call site.
Accounting for such exceptions would lead to vast numbers of
false positive warnings, so the Resource Leak Checker assumes they are
never thrown.  Strictly speaking, this is an unsoundness:  it can lead to
false negatives (missed resource leaks) if the programmer catches these
exceptions, which is a discouraged practice.

\item
The Resource Leak Checker also ignores exception types that can be verified
to never occur.  In particular, the Resource Leak Checker ignores \<NullPointerException>s
(use the Nullness Checker, \chapterpageref{nullness-checker}) and
\<ArrayIndexOutOfBoundsException>s and \<NegativeArraySizeException>s (use the Index
Checker, \chapterpageref{index-checker}). Other exception types may be added to this
list in the future.  Please let us know if there is a type that you think should
be ignored by filing an issue listing both the exception type and the
verification tool.
\end{itemize}

The set of ignored exception types can be controlled with the option
\<-AresourceLeakIgnoredExceptions=...>.  The option takes a comma-separated list of
fully-qualified exception types.  A type can be prefixed with \<=> to ignore exactly
that type and not its subclasses.  For example, for a very pedantic set of ignored
exceptions use:

\begin{verbatim}
  -AresourceLeakIgnoredExceptions=java.lang.Error, =java.lang.NullPointerException
\end{verbatim}

which ignores \<java.lang.Error> (and all its subclasses) as well as
\<java.lang.NullPointerException> (but not its subclasses).

The keyword \<default> will expand to the default set of ignored exceptions.  So,
to add an additional exception to the set of ignored exceptions, use:

\begin{verbatim}
  -AresourceLeakIgnoredExceptions=default,package.MyCustomException
\end{verbatim}

\sectionAndLabel{Errors about field initialization}{resource-leak-field-initialization}

% Arguably, this is working around a bug in the
% MustCallConsistencyAnalyzer, which could be improved to avoid issuing
% these false positive warnings.

The Resource Leak Checker warns about re-assignments to owning fields,
because the value that was overwritten might not have had its obligations
satisfied.  Such a warning is not necessary on the first assignment to a
field, since the field had no content before the assignment.  Sometimes,
the Resource Leak Checker is unable to determine that an assignment is the
first one, so it conservatively assumes the assignment is a re-assignment
and issues an error.

One way to prevent this false positive warning is to declare the field as \<final>.

Alternately, to suppress all warnings related to field assignments in the
constructor and in initializer blocks, pass the
\<-ApermitInitializationLeak> command-line argument.  This makes the
checker unsound:  the Resource Leak Checker will not warn if the constructor
and initializers set a field more than once.  The amount of leakage is
limited to how many times the field is set.

\sectionAndLabel{Errors about unknown must-call obligations}{resource-leak-generic-unknown}

The Resource Leak Checker issues a \<required.method.not.known> error
when a variable with the type \MustCallUnknown has a must-call obligation.
The Must Call Checker
only uses \MustCallUnknown when encountering a language
feature that it is unable to reason about.
If you encounter this error, usually you should write an explicit \<@MustCall> annotation
on the indicated expression (e.g., as a cast).

\pagebreak

\sectionAndLabel{Collections of resources}{resource-leak-collections}

The Resource Leak Checker handles homogeneous collections of resources. Arrays and implementing classes of \<Java.util.Collection> are supported. In a homogeneous collection, every element
has exactly the same must-call and called-methods properties.

For many operations that are intended to change the type of the collection elements, for instance to fulfill calling obligations, the only way to do so while maintaining
homogeneity is by using a loop.  The Resource Leak Checker permits
specific types of loops, as explained below.

\subsectionAndLabel{\<@MustCall> and \<@CalledMethods> for collections}{resource-leak-collections-mcoe-cmoe}
\MustCallOnElements and \<@CalledMethodsOnElements> provide similar semantics for collections as \<@MustCall> and \<@CalledMethods> do for objects.

The type hierarchy is the following:

\begin{verbatim}
              MustCallOnElementsUnknown
                           |
            MustCallOnElements({"a", "b"})
               /                     \
MustCallOnElements({"b"})       MustCallOnElements({"a"})
               \                    /
               MustCallOnElements({})
\end{verbatim}

The default type is \<@MustCallOnElements(\{\})> (bottom) for everything except
\<@OwningCollection> fields and \<@OwningCollection> parameters. For those, the
default \MustCallOnElements value is the \<@MustCall> value of the component
type. For example, the default type of an \<@OwningCollection Socket[]> is
\<@MustCallOnElements({"close"})>, since \<Socket> has \<@MustCall("close")>
type. This reduces the need for many manual annotations.

The fulfilled obligations are stored in the \<@CalledMethodsOnElements> type annotation with the following type hierarchy:
\begin{verbatim}
                      CalledMethodsOnElements({})
                      /                        \
CalledMethodsOnElements({"b"})           CalledMethodsOnElements({"a"})
                      \                        /
                 CalledMethodsOnElements({"a", "b"})
                                   |
                    CalledMethodsOnElementsBottom
\end{verbatim}
The default type for any declaration is top, that is, \<@CalledMethodsOnElements(\{\})>.

\subsectionAndLabel{Declaration of collections of resources}{resource-leak-collections-declaration}

To indicate that each resource in a collection is owned by the reference, write the \<@OwningCollection> declaration annotation:

\begin{Verbatim}
@OwningCollection Socket[] s = new Socket[n];
// The type of `s` is now  @MustCallOnElements({}) @CalledMethodsOnElements({})
\end{Verbatim}

The same annotation can be used on implementing classes of \<Java.util.Collection>, for example a List:
\begin{Verbatim}
@OwningCollection List<Socket> s = new ArrayList<Socket>();
// The type of `s` is now  @MustCallOnElements({}) @CalledMethodsOnElements({})
\end{Verbatim}

Initially, \<s> is \<@MustCallOnElements({})>, i.e. the collection has no calling obligations, since it does not yet hold any resources. Here, \<s> is a local variable. For method parameters and fields, the default type of \<@OwningCollection> references is \<@MustCallOnElements(S)>, where S is the set of \<@MustCall> obligations of the component type. If \<s> was a field or method parameter, its default type would be \<@MustCallOnElements({"close"})>, since Socket is \<MustCall("close")>.

Since \<s> has no open calling obligations, we can simply assign a \<Socket> to its elements. Now, the type of \<s> is \<@MustCallOnElements({"close"})> and the obligation for the created \<Socket> is fulfilled by assigning it into the \<@OwningCollection>:

\begin{verbatim}
@OwningCollection Socket[] s = new Socket[n];
// The type of `s` is now  @MustCallOnElements({}) @CalledMethodsOnElements({})
try {
  s[0] = new Socket(myHost, myPort); // illegal assignment
} catch (Exception e) {
}
// The type of `s` is now  @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
\end{verbatim}

Since an array assignment potentially makes the element that previously lived there unreachable, it is not safe to assign to an array with open calling obligations. That means that a subsequent write to the array reports an error, even if it is to an index that was not previously inhabited:

\begin{verbatim}
// Assume the type of `s` is @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
try {
  s[1] = new Socket(myHost, myPort); // illegal assignment
} catch (Exception e) {
}
\end{verbatim}

\begin{verbatim}
error: [illegal.owningcollection.overwrite] Elements of @OwningCollection s overwritten
 with possibly open obligations: method close.
      s[1] = new Socket(myHost, myPort);
      ^
\end{verbatim}

If multiple elements are to be assigned to an \<@OwningCollection> array, a special syntax-matched assigning loop should be used (Section~\ref{resource-leak-collections-assign-elements}).

For collections on the other hand, many commonly used methods for assigning elements to the collection are not overwriting. This means that the operation has no precondition regarding the \<@MustCallOnElements> type of the \<@OwningCollection> and may always be executed. For example, consider the local variable \<socketList>:

\begin{verbatim}
@OwningCollection List<Socket> socketList = new List<Socket>();
// The type of `s` is @MustCallOnElements({}) @CalledMethodsOnElements({})
try {
  s.add(new Socket(myHost, myPort));
}
// Now, the type of `s` is @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
try {
  s.add(new Socket(myHost, myPort));
}
// The type of `s` is still @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
\end{verbatim}

Calling \<add(Socket)> on the \<@OwningCollection> \textit{socketList} removes the obligation for the Socket object and instead unites its \<@MustCall> type values with the \MustCallOnElements type values of \textit{socketList}, meaning in this case that \textit{socketList} now has type  \<@MustCallOnElements({"close"})>. In general, a writing method on a collection unites the \<@MustCall> type values of the argument to the \<@MustCallOnElements> type values of the collection and removes the obligation of the argument.

If \<socketList> was a field, the rules are slightly more constrained and discussed in detail in Section~\ref{resource-leak-collections-fields}.

Using any non-overwriting method, such as \<Collection.add(E)>, the discussed lack of precondition for the operation means that it can be used arbitrarily, also in loops without any additional constraints by the checker. The following loop is perfectly legal for example:

\begin{verbatim}
@OwningCollection List<Socket> socketList = new List<Socket>();
// The type of `s` is @MustCallOnElements({}) @CalledMethodsOnElements({})
int i = 0;
while (++i < n) {
  try {
    s.add(new Socket(myHost, myPort));
  }
  // Now, the type of `s` is @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
}
// After this loop, the type of `s` is still @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
\end{verbatim}

For overwriting methods on collections, such as \<List.set(int, E)>, the precondition is also that the \<@OwningCollection> has no open calling obligations.

Since for arrays, the only way to assign elements is by using the overwriting assignment operator, a syntax-matched loop construct with special handling is provided. It is discussed in the following section (Section~\ref{resource-leak-collections-assign-elements}). There is no such equivalent construct for overwriting methods on collections (implementing classes of \<Java.util.Collection>).

\subsectionAndLabel{Using loops to operate on collections of resources}{resource-leak-collections-loops}

In order to maintain homogeneity, code that wants to change the CalledMethodsOnElements of a collection/array or MustCallOnElements type of an array must operate using a loop. There are some constraints such that these loops are appropriately handled. Furthermore, the loop must not terminate early --- it must
operate upon every element of the collection.

Generally, the basic loop constraints are:
\begin{itemize}
\item Loop iteration bounds:
  \begin{itemize}
  \item
    The loop is an enhanced \<for> loop (``foreach loop'') over the collection, or
  \item
    The loop is an indexed \<for> loop, such that
    \begin{itemize}
    \item The lower bound of iteration is 0, and
    \item The upper bound of iteration is \<c.length> or \<c.size()> or \<n>,
      where \<n> is the effectively final variable used for the initialization of
      the array size.
    \item The loop's increment expression is a pre- or post-increment of the
            loop variable.
    \item The collection element is accessed using arr[i] (in the case of an array) or collection.get(i) (in the case of a collection).
    \item The loop body contains no assignments to the loop variable.
    \end{itemize}
  \end{itemize}
\item The loop does not terminate early: The loop body contains no \<return> or \<break> statements.
\item The loop does not assign to the collection variable.
\item The loop does not assign to collection elements, unless it is an
  assignment loop (Section~\ref{resource-leak-collections-assign-elements}).
\end{itemize}

\noindent There are additional constraints for specific types of loops, as
explained below.

The number of constraints may seem daunting, but most constraints only apply to indexed \<for> loops. If an enhanced \<for> loop is used, to fulfill the calling obligations of a List or array for example, the only constraint potentially introducing imprecision is that the loop body may not contain any break or return statements.

\subsectionAndLabel{Assigning elements in an array of resources}{resource-leak-collections-assign-elements}

Here is an example of how to assign the elements of an array of resources:

\begin{Verbatim}
// Suppose the type of `s` is  @MustCallOnElements({}) @CalledMethodsOnElements({})
for (int i = 0; i < s.length; i++) {
  try {
    s[i] = new Socket(myHost, myPort);
  } catch (Exception e) {
    // do nothing
  }
}
// The type of `s` is now @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
\end{Verbatim}

The checker accepts an assignment loop if the following requirements are
satisfied (in addition to the basic loop constraints of Section~\ref{resource-leak-collections-loops}):

\begin{itemize}
  \item The collection elements have no unfulfilled must-call-on-elements obligations.
  \item The loop is an indexed \<for> loop (not an enhanced \<for> loop).
  \item There is exactly one statement in the body. The statement is either the
    assignment or a try-catch construct that contains only the assignment.
  \item The right-hand side of the assignment creates a new resource.
    The right-hand side cannot be an expression that might evaluate to an existing resource.
  \item If there is a try-catch construct, the catch and finally blocks may
    not throw any exceptions, call any methods, or have any writes (in
    addition to the basic loop constraints of Section~\ref{resource-leak-collections-loops}).
\end{itemize}

\subsectionAndLabel{Fulfilling \MustCallOnElements obligations}{resource-leak-collection-fulfilling-obligations}

A \MustCallOnElements obligation can be fulfilled via operations on loop
elements such as \<c[i]> or \<c.get(i)>.
The loop has no constraints (beyond the basic loop constraints of
Section~\ref{resource-leak-collections-loops}), and its body may call an
arbitrary number of methods on the collection elements.

Here are two examples:

\begin{verbatim}
// Suppose the type of `arr` is @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
for (int i = 0; i < arr.length; i++) {
    try {
      arr[i].close();
      arr[i].foo();
    } catch (Exception e) {}
}
// The type of `arr` is now @MustCallOnElements({}) @CalledMethodsOnElements({"close", "foo"})
\end{verbatim}

Here is an example written as an enhanced \<for> loop:

\begin{verbatim}
// Suppose the type of `arr` is @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
for (Socket s: arr) {
    try {
        s.close();
    } catch (Exception e) {}
}
// The type of `arr` is now @MustCallOnElements({}) @CalledMethodsOnElements({"close"})
\end{verbatim}


The obligation can also be fulfilled by calling a method that has an
\<@EnsuresCalledMethods> annotation, with the collection element as an
argument:
\begin{verbatim}
// Suppose the type of `arr` is @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
for (int i = 0; i < arr.length; i++) {
    method(arr[i]); // method calls 'close' on its argument, see below
}
// The type of `arr` is now @MustCallOnElements({}) @CalledMethodsOnElements({"close"})

...

@EnsuresCalledMethods(value="#1", methods={"close"})
void method(Socket s) {
    try {
        s.close();
    } catch (Exception e) {}
}
\end{verbatim}

Here is an example for a Java \<Collection> rather than an array:

\begin{verbatim}
// Suppose the typo of `socketList` is @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
for (int i = 0; i < socketList.size(); i++) {
    try {
        socketList.get(i).close();
    } catch (Exception e) {}
}
// The type of `socketList` is now @MustCallOnElements({}) @CalledMethodsOnElements({"close"})
\end{verbatim}

The called methods are
determined by checking the \<@CalledMethods> type of the collection element at
the end of the loop body, without considering exceptional states, i.e.\ only
exception-free executions of the loop body are considered.

For example, the following loop calls the methods \<close()> and \<shutdownOutput()> on the elements of \textit{socketList}.

\begin{verbatim}
// socketList: @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
for (Socket s: socketList) {
    s.shutdownOutput();
    try {
        s.close();
    } catch (Exception e) {}
    // socketList: @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
}
// socketList: @MustCallOnElements({}) @CalledMethodsOnElements({"close", "shutdownOutput"})
\end{verbatim}

The type of the collection is changed only after the loop, not within the
loop. The loop is treated as a single instruction with regards to its effect on
the type system for this checker.

\subsectionAndLabel{Collection ownership and aliasing}{resource-leak-collections-ownership}
For a collection of resources, there is always at most one owning reference and it has an \<@OwningCollection> declaration annotation. A \textit{collection of resources} is a collection that can (legally) hold objects with must-call obligations. This is only possible for collections with an \<@OwningCollection> reference, since adding elements with must-call obligations to a collection using a non-\<@OwningCollection> reference is not permitted.

When this owning reference goes out of scope or is reassigned, the obligations of the collection must be fulfilled. That is, as long as the collection has obligations, there is \textit{exactly} one owning reference. If the owner goes out of scope or is reassigned and the collection still has obligations, an error is reported.

The checker allows for transfer of collection ownership and also for non-owning references to the resource collection. A non-owning reference to a resource collection is greatly restricted in its ability to modify the collection. It may not be used to perform any writes to the collection, and has restrictions regarding parameter passing (Section~\ref{resource-leak-collections-parameters}) and returning (Section~\ref{resource-leak-collections-return}) due to its non-owning status. These restrictions are necessary for soundness, since a non-owning reference can outlive the owner and could be used to add obligations to the collection after the owner went out of scope (or was reassigned).

This non-owning, write-disabled status is made visible by setting the \MustCallOnElements type of the reference to
\<@MustCallOnElementsUnknown>.

\subsubsectionAndLabel{Ownership transfer and resource collection aliases}{resource-leak-collections-ownership-transfer}
A reference with ownership over a resource collection holds the obligation for fulfilling the must-call obligations of the elements inside the collection. Transferring this ownership is possible, for example through assignments. When transferring ownership, the transferring reference loses its responsibility over the calling obligations, but also its write privileges.

Consider this example with local variables:

\begin{Verbatim}
@OwningCollection Socket[] s = new Socket[n]; // allocation point A
@OwningCollection Socket[] s2 = new Socket[n]; // allocation point B
s2 = 2; // s2 now has ownership over the array allocated at A
\end{Verbatim}

For such an ownership transfer, the previous owner (right-hand side of the assignment) becomes a non-owning, write-disabled reference.

The \<@MustCallOnElements> obligations of a resource collection can also be fulfilled by such a collection alias of the owner, similar to resource aliases for simple objects (Section~\ref{resource-leak-resource-alias}), as long as the fulfilment occurs before the owner leaves the scope.

In the above example, the assignment also causes the array allocated at point B to go out of scope, since its owner got reassigned. Since it doesn't have open calling obligations, no error is reported however.

As previously mentioned, when a write-disabled reference is used to write to the underlying collection, an error is reported:

\begin{Verbatim}
@OwningCollection Socket[] s = new Socket[n];
@OwningCollection Socket[] s2 = new Socket[n];
s2 = 2; // s2 now has ownership over the array of elements
s[0] = null; // illegal assignment
\end{Verbatim}

\begin{Verbatim}
  error: [modification.without.ownership] s does not have ownership over its elements.
  It may not write to or remove elements from the underlying collection.
    s[0] = null;
         ^
\end{Verbatim}

Thus, if a collection reference is annotated \<@OwningCollection>, it means that it \textit{can} have ownership over its underlying collection, but it can also lose this ownership, as in the example above and become a write-disabled alias to the underlying collection.
However, if the reference is reassigned, for example to a new collection, it will again have ownership:

\begin{verbatim}
@OwningCollection Socket[] s = new Socket[n];
@OwningCollection Socket[] s2 = new Socket[n];
s2 = 2; // s is a write-disabled reference
s[0] = null; // illegal assignment

s = new Socket[n]; // s now owns this new array
try {
  s[0] = new Socket(myHost, myPort); // s can assign elements
} catch (Exception e) {
}
\end{verbatim}

\subsubsectionAndLabel{Non-\<@OwningCollection> references}{resource-leak-collections-aliases}
It's also possible to assign a reference without \<@OwningCollection> annotation to such a resource holding collection. In that case, the ownership will not be transferred and the left-hand side becomes a write-disabled reference:

\begin{Verbatim}
@OwningCollection Socket[] s = new Socket[n];
Socket[] s2 = new Socket[n]; // s2 is not @OwningCollection
s2 = 2; // s2 is now a write-disabled reference
s2[0] = null; // illegal assignment
\end{Verbatim}

\begin{Verbatim}
  error: [modification.without.ownership] s does not have ownership over its elements.
  It may not write to or remove elements from the underlying collection.
    s2[0] = null;
         ^
\end{Verbatim}

\subsubsectionAndLabel{Types of references to resource collections}{resource-leak-collections-reference-types}
To conclude, we have four different types of references regarding collection ownership:
\begin{enumerate}
  \item \<@OwningCollection> references that own their collection. They can transfer their ownership, for example by being the right-hand side of an assignment, a return value (Section~\ref{resource-leak-collections-return}) or a method argument (Section~\ref{resource-leak-collections-parameters}) to become a type 2 reference.
  \item \<@OwningCollection> references that transferred their ownership and are now a write-disabled alias to a resource collection. They can become a type 1 reference again by being assigned to a type 1 reference, a new collection or an \<@OwningCollection> return value (Section~\ref{resource-leak-collections-return}).
  \item Non-\<@OwningCollection> references that are a write-disabled alias to a resource collection. The aliasing status can be gained through assignment to a resource collection (type 1, 2 or 3) or being declared a \<@CollectionAlias> parameter (Section~\ref{resource-leak-collections-parameters}).
  \item Non-\<@OwningCollection> references that do not refer to a resource collection. By getting assigned to a resource collection, such a reference would become a type 3 reference.
\end{enumerate}

\noindent References of types 1, 2 and 3 refer to resource collections, while those of type 4 do not.

\noindent References of types 2 and 3 always have \<@MustCallOnElementsUnknown> type, which is how the write-disabling is implemented. References of type 4 always have \<@MustCallOnElements({})> type and references of type 3 always have a strict subtype of \<@MustCallOnElementsUnknown>.

The following table shows the resulting reference type of the left-hand side and right-hand side when assigning a reference of the column to one of the row. The columns and rows contain the reference description rather than the number for a better overview. Reference types that change through the assignment are in bold.

\begin{table}[ht]
    \centering
    \caption{Resulting references types for LHS/RHS of an assignment.}
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{LHS / RHS} & \textbf{@OC Owner} & \textbf{@OC Write-Disabled} & \textbf{Write-Disabled} & \textbf{No Resource Collection} \\ \hline
        \textbf{@OC Owner} & Type 1 / \textbf{Type 2} & \textbf{Type 2} / Type 2 & \textbf{Type 2} / Type 3 & Type 1 / Type 4 \\ \hline
        \textbf{@OC Write-Disabled} & \textbf{Type 1} / \textbf{Type 2} & Type 2 / Type 2 & Type 2 / Type 3 & \textbf{Type 1} / Type 4 \\ \hline
        \textbf{Write-Disabled} & Type 3 / Type 1 & Type 3 / Type 2 & Type 3 / Type 3 & \textbf{Type 4} / Type 4 \\ \hline
        \textbf{No Resource Collection} & \textbf{Type 3} / Type 1 & \textbf{Type 3} / Type 2 & \textbf{Type 3} / Type 3  & Type 4 / Type 4 \\ \hline
    \end{tabular}
    \label{tab:abstract_domain_results_with_errors}
\end{table}

Note that references can only switch between types 1/2 and 3/4, since types 1/2 have an \<@OwningCollection> declaration annotation, while types 3/4 do not.

\subsectionAndLabel{Collection ownership transfer for argument passing}{resource-leak-collections-parameters}
There are three options for a resource collection parameter. The rules for methods and constructors are the same. In the following, we use the reference classification from Section~\ref{resource-leak-collections-reference-types}.
\begin{enumerate}
  \item \texttt{No annotation}: The parameter has no obligations to fulfill, but also cannot hold elements with must-call obligations. At call-site, only type-4-reference arguments may be passed to the parameter.
  \item \texttt{\<@OwningCollection>}: The parameter owns the collection. The \<MustCallOnElements> type of the parameter defaults to the \<MustCall> values of its component (but this may be overwritten by a manual annotation). Only type-1-reference arguments may be passed to this parameters and they transfer their ownership to the parameter, i.e. the passed argument becomes a type-2-reference at call site.
  \item \texttt{\<@CollectionAlias>}: The parameter is a write-disabled (i.e. type 2) reference to the underlying collection and thus restricted in its ability to modify the collection, but it does not have to fulfill any obligations. Arguments of reference types 1, 2 and 3 may be passed to such a parameter. If the argument is a type 1 reference, it keeps its ownership. Technically, type 4 references can also be passed as arguments to a \<@CollectionAlias> parameter, but this places unnecessary restrictions on the parameter.
\end{enumerate}

Here is an example of an \<@OwningCollection> parameter:
\begin{verbatim}
void m1(@OwningCollection Socket[] s) {
  // 's' is @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
  for (int i = 0; i < s.length; i++) {
    try {
      s.close();
    } catch {}
  }
  // 's' is @MustCallOnElements({}) @CalledMethodsOnElements({"close"})
}
\end{verbatim}

If the method expects an array of \<Socket>s that are already closed (or not yet initialized) and thus has no open \<@MustCallOnElements> obligation, this can be specified with a manual annotation to override the default.

\begin{verbatim}
void m1(@OwningCollection Socket@MustCallOnElements()[] s) {
  // 's' is @MustCallOnElements({}) @CalledMethodsOnElements({})
  ...
}
\end{verbatim}

\subsectionAndLabel{Collection ownership transfer at method returns}{resource-leak-collections-return}
Like for parameters, there are three options for returning a resource collection:
We again use the collection reference classification from Section~\ref{resource-leak-collections-reference-types}.
\begin{enumerate}
  \item \texttt{No annotation}: At call site, the return value is a type 4 reference. Thus, only type 4 references may be returned.
  \item \texttt{\<@OwningCollection>}: At call site, the return value is a type 1 reference. Only type 1 references may be returned. This means that the ownership of the return value is transferred to the call site and thus the return value reference does not have to fulfill the \<@MustCallOnElements> obligations before being returned.
  \item \texttt{\<@CollectionAlias>}: At call site, the return value is a type 3 reference. Only type 2 and type 3 references may be returned. Since both type 2 and type 3 are non-owning, write-disabled aliases, there is no ownership transfer.
\end{enumerate}

Here is an example of an \<@OwningCollection> return type:
\begin{verbatim}
@OwningCollection Socket[] owningReturn() {
  @OwningCollection Socket[] s = new Socket[n];
  // 's' is @MustCallOnElements({}) @CalledMethodsOnElements({})
  for (int i = 0; i < s.length; i++) {
    try {
      s[i] = new Socket(myHost, myPort);
    } catch {}
  }
  // 's' is @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
}
\end{verbatim}

This method is perfectly fine, returning \<s> as an \<@OwningCollection> transfers the ownership to the call site and \<owningReturn()> does not have to fulfill the obligation itself.

\subsectionAndLabel{\<@OwningCollection> fields}{resource-leak-collections-fields}

An \<@OwningCollection> field must be final, private, and non-static. Thus, it
can only be assigned in the constructor, in an instance initializer block, or at the declaration site.
The default type of such a collection after declaration is \<@MustCallOnElements(obligation)>, where \textit{obligation} is the set of \<@MustCall> methods of the component type. The default \<@CalledMethodsOnElements> type is the empty \<@CalledMethodsOnElements({})>. This default type can be changed with a manual \<@MustCallOnElements> annotation.

For example, the following field has an empty \<@MustCallOnElements> type:

\begin{verbatim}
@OwningCollection @MustCallOnElements() List<Socket> listField;
\end{verbatim}

The \<@MustCallOnElements> type of an \<@OwningCollection> field is invariant over the lifetime of the object. That is, the declared \<@MustCallOnElements> type of the field is an upper bound and is not allowed to increase.

This imposes some restrictions on \<@OwningCollection> fields to ensure soundness:

\begin{itemize}
  \item An \@OwningCollection> field cannot transfer its ownership. This means that it cannot be passed as an argument to an \<@OwningCollection> parameter, be returned or be on the right-hand side of an assignment where the left-hand side is an \<@OwningCollection> reference. The reason is that this would require tracking whether the method containing this assignment has been invoked on any instance of the class and change the behavior of the field after that (it would now be write-disabled). Since the checker framework does not do this type of analysis, ownership transfers of an \<@OwningCollection> field are not permitted.
  \item The elements of an \<@OwningCollection> array field can only be assigned in the constructor (and using only one assignment loop).
  \item Any overwriting writes to the collection elements outside the constructor are not allowed. This is because the precondition of an overwriting write is that the collection has no open obligations, which is never the case for an \<@OwningCollection> field.
\end{itemize}

Since the lifetime of a field coincides with the lifetime of the class instance, the obligations of the field must be fulfilled by the time the object itself is deallocated.
A class with an \<@OwningCollection> field has to have a \<@MustCall("d")> annotation, where \<d()> is some destructor method that fulfills all obligations of the \<@OwningCollection> fields, indicated by an appropriate \<@EnsuresCalledMethodsOnElements> annotation:

\begin{verbatim}
@MustCall("destruct")
class A {
    final @OwningCollection Resource[] arr = new Resource[10];
    ...
    @EnsuresCalledMethodsOnElements(value="arr", methods={"close"})
    public void destruct() {
        for (Resource r : arr) {
            r.close();
        }
    }
}
\end{verbatim}

This ensures that any client that constructs an instance of \<A> will have to call \<destruct()> on it, which in turn ensures that the obligations of the field are fulfilled.

\subsectionAndLabel{Iterators over resource collections}{resource-leak-collections-iterators}
Iterators are frequently used to traverse collections (implementing classes of \<java.util.Collection>). It is always safe to create an iterator for any collection with no open calling obligations. Since an iterator takes a snapshot of the collection at the time it is created, it does not matter what happens with the collection after the iterator is created (else, a \<ConcurrentModificationException> is thrown for the next usage of the iterator).
If a collection with open \<MustCallOnElements> obligations (even if it is a non-owning reference) creates an iterator, the resource leak checker tracks the created iterators and the values returned by calls to \<Iterator.next()>. The critical operation are calls to \<Iterator.remove()>. If a collection has open calling obligations, this may remove an element from the collection with open \<MustCall> obligations. This is only allowed if the value returned by the previous call to \<Iterator.next()> has its \<MustCall> obligations fulfilled.

Here is an example of unsafe iterator usage:

\begin{verbatim}
@OwningCollection List<Socket> foo(@OwningCollection List<Socket> list) {
  // 'list' is @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
  Iterator<Socket> iter = list.iterator();
  iter.next();
  iter.remove();
  return list;
}
\end{verbatim}

Since \<list> is \<@MustCallOnElements("close")>, removing an element using the iterator is unsafe and an error is reported:
\begin{verbatim}
 error: [required.method.not.called] @MustCall method close may not have been invoked on iter.next() or any of its aliases.
    iter.next();
             ^
\end{verbatim}

The removed element must have its must-call obligations fulfilled. Here is an example of safe usage:

\begin{verbatim}
@OwningCollection List<Socket> foo(@OwningCollection List<Socket> list) {
  // 'list' is @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
  Iterator<Socket> iter = list.iterator();
  try {
    iter.next().close();
  } catch (Exception e) {
  }
  iter.remove();
  return list;
}
\end{verbatim}

The returned element may also be stored in a variable first and the fulfillment of the obligation of the returned element may also occur after the call to \<remove()>:

\begin{verbatim}
@OwningCollection List<Socket> foo(@OwningCollection List<Socket> list) {
  // 'list' is @MustCallOnElements({"close"}) @CalledMethodsOnElements({})
  Iterator<Socket> iter = list.iterator();
  Socket s = iter.next();
  iter.remove();
  try {
    s.close();
  } catch (Exception e) {
  }
  return list;
}
\end{verbatim}

The returned element by \<iter.next()> may have its must-call obligation fulfilled in any way described by the resource leak checker, even by transferring its ownership.

Iterators over collections with obligations may also be returned, passed as method or constructor arguments and even be stored in fields. This has some consequences for iterator fields, return types and method/constructor parameters:
\begin{itemize}
  \item If the iterator component type has non-empty \<MustCall> type, for any call to \<Iterator.remove()>, the value returned by the preceding call to \<Iterator.next()> must fulfill its must-call obligaitons.
  \item If the iterator component type has non-empty \<MustCall> type, any call to \<Iterator.remove()> without preceding call to \<Iterator.remove()> in the same method is unsafe. If the iterator is for example a field, the corresponding \<Iterator.next()> call could have come from a member method.
\end{itemize}

% \sectionAndLabel{Collections of resources (old)}{resource-leak-collections-old}

% The Resource Leak Checker cannot verify code that stores a collection of
% resources in a generic collection (e.g., \<java.util.List>) and then
% resolves the obligations of each element of the collection at once (e.g.,
% by iterating over the \<List>).  In the future, the checker will support
% this.  The remainder of this section explains the implementation issues;
% most users can skip it.

% The first implementation issue is that \<@Owning> and \<@NotOwning> are
% declaration annotations rather than type qualifiers, so they cannot be
% written on type arguments. It is possible under the current design to have
% an \code{@Owning List<Socket>}, but not a \code{List<@Owning Socket>}.
% It would be better to make \<@Owning> a type annotation, but this is a
% challenging design problem.

% The second implementation issue is the defaulting rule for \<@MustCall> on
% type variable upper bounds.  Currently, this default is \<@MustCall(\{\})>,
% which prevents many false positives in code with type variables that makes
% no use of resources --- an important design principle.
% However, this defaulting rule does have an unfortunate consequence: it is
% an error to write \code{List<Socket>} or any other type with a concrete
% type argument where the type argument itself isn't \<@MustCall(\{\})>. A programmer who
% needs to write such a type while using the Resource Leak Checker has a few
% choices, all of which have some downsides:

% \begin{itemize}
% \item Write \code{List<? extends Socket>}. This rejects calls to \<add()>
% or other methods that require an instance of the type variable, but it
% preserves some of the behavior (e.g., calls to \<remove()> are permitted).
% This is the best choice most of the time if the \<List> is not intended to
% be owning.
% \item Write \code{List<@MustCall Socket>}. This makes it an error to
% add a Socket to the list, since the type of the Socket is
% \<@MustCall("close")> but the list requires \<@MustCall()>.
% \item Suppress one or more warnings.
% \end{itemize}

% The recommended way to use the Resource Leak Checker in this situation is
% to rewrite the code to avoid a \<List> of owning resources. If rewriting is
% not possible, the programmer will probably need to suppress a warning and
% then verify the code using a method other than the Resource Leak Checker.


\sectionAndLabel{Resource Leak Checker annotation inference algorithm}{resource-leak-checker-inference-algo}

The Resource Leak Checker uses a specialized algorithm to infer annotations
when whole program inference (WPI, Section~\ref{whole-program-inference})
is enabled.  The algorithm is described in the paper ``Inference of
Resource Management Specifications''~\cite{ShadabGTEKLLS2023} (OOPSLA 2023,
\myurl{https://homes.cs.washington.edu/~mernst/pubs/resource-inference-oopsla2023-abstract.html}).


% LocalWords:  de subchecker OutputStream MustCall MustCallUnknown RAII Un Un
% LocalWords:  PolyMustCall InheritableMustCall MultiRandSelector callsite mcoe
% LocalWords:  Partitioner CalledMethods AnoLightweightOwnership NotOwning cmoe
% LocalWords:  AnoResourceAliasing MustCallAlias AnoCreatesMustCallFor unclosed
% LocalWords:  EnsuresCalledMethods CreatesMustCallFor expr Verification'' s2
% LocalWords:  closeSocket destructor'' destructor BufferedOutputStream close''
% LocalWords:  AnoResourceAliases createsmustcallfor SocketContainer intra m1
% LocalWords:  CalledMethodsBottom CollectionIndexOutOfBoundsException foreach
% LocalWords:  NegativeCollectionSizeException ApermitStaticOwning InputStream
% LocalWords:  AresourceLeakIgnoredExceptions ApermitInitializationLeak loop''
% LocalWords:  MustCallOnElements OwningCollection InputStreamWrapper algo WPI
% LocalWords:  EnsuresCalledMethodsOnException EnsuresCalledMethodsOnElements
% LocalWords:  EnsuresCalledMethodsOnElementsOnException ClassCircularityError
% LocalWords:  ClassFormatError NoClassDefFoundError NegativeArraySizeException
% LocalWords:  ArrayIndexOutOfBoundsException CalledMethodsOnElements
% LocalWords:  socketList shutdownOutput MustCallOnElementsUnknown
% LocalWords:  Specifications''
